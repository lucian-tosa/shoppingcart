# Notes

- Firstly, I noticed that items appeared only as Strings, which doesn't leave a lot of room for improvement, so I decided to implement an Object which encapsulates data related to items and in this way, new attributes can be easily added.
- For keeping track of the items, there were 2 ways to go about printing the items in the order they were scanned. Either combine items of the same type that are scanned at different times, or leave them as separate. Even though the latter is the way that most supermarkets do it, I decided it would be easier for consumers to have the same type of item grouped together. Thus if we buy apples, bananas, apples, we will print on the receipt bananas and apples, since apples appeared last.
- For storing the entries on the receipt I created another class, ReceiptItem, which encapsulates the item that was bought, the amount and the price per piece (and also an order integer which is used for keeping the order when building the receipt). This class also allows to easily add new features: for example, discounts on individual items.
- For the actual printing, I decided to extract this functionality from the shopping cart since it shouldn't implement all the features. Thus I implemented a Strategy design pattern with the ReceiptFormat interface. An implementation of this interface is TotalFirstFormat, which is the format described in the description, but a new format can be easily implemented without changing existing code. This ReceiptFormat also does not depend on the ShoppingCart implementation, so that can be changed freely, instead, it depends on the ReceiptItem object.
- By externalizing this feature to another class, I have removed the problem of constantly updating the tests, since I introduced mocking for testing the ShoppingCart, and testing the actual printing of the receipt is done by testing each individual implementation of the ReceiptFormat strategy.
- I also noticed that prices were stored in Integer formats in cents, which I found a bit counterintuitive, so I used Double instead since it provides the necessary precision for these types of operations.
- Regarding error handling, I would have wanted to implement exceptions, but since this is considered part of a big system, that would cause more problems. Nonetheless, I added some error handling by ignoring, or substituting invalid numbers, such as non-positive amounts and negative prices.